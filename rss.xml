<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://newzone.top/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://newzone.top/rss.xml" rel="self" type="application/rss+xml"/>
    <title>zxy</title>
    <link>https://newzone.top/</link>
    <description>我要确认这是不是我此生唯一的机会</description>
    <language>zh-CN</language>
    <pubDate>Mon, 14 Aug 2023 09:09:38 GMT</pubDate>
    <lastBuildDate>Mon, 14 Aug 2023 09:09:38 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>复盘总结</category>
    <category>笔记</category>
    <category>基础</category>
    <category>前端</category>
    <item>
      <title>公告栏</title>
      <link>https://newzone.top/notice.html</link>
      <guid>https://newzone.top/notice.html</guid>
      <source url="https://newzone.top/rss.xml">公告栏</source>
      <description>公告 本站处于初期建设阶段，内容将不断完善。 0.1- 网站日志 2022/10/01: 本网站建立于 2023-08-14，目前仍处于建设阶段，内容在不断完善中。。。 0.2- 建站计划 搭建并部署网站 个人介绍 搬运历史随笔文章 选择一个合适的图床 把图片搬运到自己的图床 完善「生活」板块 生活习惯 运动记录 健康养生 读书笔记 软件安利 游戏笔记 完善「学习笔记」板块 开发笔记 Java 笔记 Python 笔记 Vue 笔记 Linux 笔记 算法笔记 优化笔记分区 优化侧边栏体验</description>
      <pubDate>Tue, 18 Apr 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">公告</p>
<p>本站处于<strong>初期建设</strong>阶段，内容将不断完善。</p>
</div>
<h2> 0.1- 网站日志</h2>
<ul>
<li>2022/10/01: 本网站建立于 2023-08-14，目前仍处于建设阶段，内容在不断完善中。。。</li>
</ul>
<h2> 0.2- 建站计划</h2>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 搭建并部署网站</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="/_draft/intro.html" target="blank">个人介绍</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 搬运历史<a href="/note/" target="blank">随笔文章</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 选择一个合适的图床</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 把图片搬运到自己的图床</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 完善<a href="/life/" target="blank">「生活」板块</a></label>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> 生活习惯</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> 运动记录</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> 健康养生</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> 读书笔记</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> 软件安利</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-11" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-11"> <a href="/life/game/" target="blank">游戏笔记</a></label></li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-12" disabled="disabled"><label class="task-list-item-label" for="task-item-12"> 完善「学习笔记」板块</label>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-13" disabled="disabled"><label class="task-list-item-label" for="task-item-13"> <a href="/code/" target="blank">开发笔记</a></label>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-14" disabled="disabled"><label class="task-list-item-label" for="task-item-14"> Java 笔记</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-15" disabled="disabled"><label class="task-list-item-label" for="task-item-15"> <a href="/code/language/python/" target="blank">Python 笔记</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-16" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-16"> <a href="/code/frontend/vue.html" target="blank">Vue 笔记</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-17" disabled="disabled"><label class="task-list-item-label" for="task-item-17"> Linux 笔记</label></li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-18" disabled="disabled"><label class="task-list-item-label" for="task-item-18"> 算法笔记</label></li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-19" disabled="disabled"><label class="task-list-item-label" for="task-item-19"> 优化笔记分区</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-20" disabled="disabled"><label class="task-list-item-label" for="task-item-20"> 优化侧边栏体验</label></li>
</ul>
<p>内容积极填充中。。。</p>
<h2> 0.3- 目前存在的问题</h2>
<ul>
<li>RSS 功能似乎不能使用</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>comic</title>
      <link>https://newzone.top/life/comic.html</link>
      <guid>https://newzone.top/life/comic.html</guid>
      <source url="https://newzone.top/rss.xml">comic</source>
      <description>1- 漫画对于我来说是什么 精神世界的极大满足 代替自己的眼睛和想象力在未知的世界自由畅享 无可替代</description>
      <pubDate>Mon, 14 Aug 2023 15:26:43 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1- 漫画对于我来说是什么</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 精神世界的极大满足</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 代替自己的眼睛和想象力在未知的世界自由畅享</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 无可替代</label></li>
</ul>
<h1> 2- list</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 大剑</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 剑风传奇</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 铳梦</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> 攻壳机动队</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> 海贼王</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> 炎拳</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> 电锯人</label></li>
</ul>
<h1> 3- 待看</h1>
]]></content:encoded>
    </item>
    <item>
      <title>movie</title>
      <link>https://newzone.top/life/movie.html</link>
      <guid>https://newzone.top/life/movie.html</guid>
      <source url="https://newzone.top/rss.xml">movie</source>
      <description>1- 电影对于我来说是什么 精神世界的极大满足 代替自己的眼睛和想象力在未知的世界自由畅享 无可替代</description>
      <pubDate>Mon, 14 Aug 2023 15:26:43 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1- 电影对于我来说是什么</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 精神世界的极大满足</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 代替自己的眼睛和想象力在未知的世界自由畅享</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 无可替代</label></li>
</ul>
<h1> 2- comic list</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 新海诚</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 宫崎骏</label></li>
</ul>
<h1> 3- love list</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> before sunrise</label></li>
</ul>
<h1> 4- spirit list</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> 死亡诗社</label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>music</title>
      <link>https://newzone.top/life/music.html</link>
      <guid>https://newzone.top/life/music.html</guid>
      <source url="https://newzone.top/rss.xml">music</source>
      <description>1- 音乐对于我来说是什么 精神世界的极大满足 代替自己的眼睛和想象力在未知的世界自由畅享 无可替代</description>
      <pubDate>Mon, 14 Aug 2023 15:26:43 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1- 音乐对于我来说是什么</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 精神世界的极大满足</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 代替自己的眼睛和想象力在未知的世界自由畅享</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 无可替代</label></li>
</ul>
<h1> 2- pure list</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 新海诚</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 宫崎骏</label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>八月随笔</title>
      <link>https://newzone.top/note/%E5%85%AB%E6%9C%88%E9%9A%8F%E7%AC%94.html</link>
      <guid>https://newzone.top/note/%E5%85%AB%E6%9C%88%E9%9A%8F%E7%AC%94.html</guid>
      <source url="https://newzone.top/rss.xml">八月随笔</source>
      <description>1- 八月的目标 搭建个人网站（借助互联网的力量 完成CEA论文的回稿 和 论文实验的复现 构建自身的习惯系统 学习系统回路 健康系统回路 生活系统回路</description>
      <category>复盘总结</category>
      <pubDate>Mon, 14 Aug 2023 16:23:25 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1- 八月的目标</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 搭建个人网站（借助互联网的力量</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 完成CEA论文的回稿 和 论文实验的复现</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 构建自身的习惯系统</label>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 学习系统回路</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 健康系统回路</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 生活系统回路</label></li>
</ul>
</li>
</ul>
<h2> 1.1- 2023-08-14</h2>
]]></content:encoded>
    </item>
    <item>
      <title>Git 笔记</title>
      <link>https://newzone.top/code/basic/git.html</link>
      <guid>https://newzone.top/code/basic/git.html</guid>
      <source url="https://newzone.top/rss.xml">Git 笔记</source>
      <description>提示 Git 是一个非常常用的代码版本控制程序，算是每个开发者必备的技能。本笔记前半部分罗列了一些 Git 的常用指令，后半部分介绍了 Git 的相关概念。 Git 常用指令 查看版本：git log (--pretty=oneline) &amp;nbsp;图形：git log --graph --pretty=oneline --abbrev-commit</description>
      <category>笔记</category>
      <category>基础</category>
      <pubDate>Mon, 14 Aug 2023 09:07:38 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>Git 是一个非常常用的代码版本控制程序，算是每个开发者必备的技能。本笔记前半部分罗列了一些 Git 的常用指令，后半部分介绍了 <a href="#git-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-%E5%9F%BA%E7%A1%80%E7%AF%87">Git 的相关概念</a>。</p>
</div>
<h2> Git 常用指令</h2>
<p>查看版本：<code>git log (--pretty=oneline)</code> &nbsp;图形：<code>git log --graph --pretty=oneline --abbrev-commit</code></p>
<p>查看历史命令：<code>git reflog</code></p>
<p>回退到目标版本：<code>git reset --hard (版本号/HEAD^/HEAD~n)</code></p>
<p>将文件加入暂存区：<code>git add (文件名/.)</code></p>
<p>将暂存区的内容提交：<code>git commit -m "说明"</code></p>
<p>将工作区中的内容撤销到上一次add或commit命令的状态：<code>git checkout–(文件名)</code></p>
<p>将暂存区的内容撤销：<code>git reset HEAD (文件名)</code></p>
<p><code>git reset --patch (filename)</code></p>
<p>在工作区删除文件，并将删除操作加入暂存区：<code>git rm (文件名)</code></p>
<p>🌟 撤销commit，保留修改的代码：<code>git reset --soft HEAD^</code></p>
<ul>
<li>--mixed：不删除工作空间改动代码，撤销commit，撤销add</li>
<li>--soft：不删除工作空间改动代码，撤销commit，不撤销add</li>
<li>--hard：删除改动代码，撤销commit，撤销add</li>
</ul>
<hr>
<h3> 分支</h3>
<ul>
<li>创建分支：<code>git branch (branch_name)</code></li>
<li>切换分支：<code>git checkout (branch_name)</code></li>
<li>创建并切换到分支：<code>git checkout -b (branch_name)</code></li>
<li>切换到远程分支：<code>git checkout -b (branch_name) origin/2.3-dev</code></li>
<li>查看当前所有分支：<code>git branch</code>，查看远程所有分支：<code>git branch -r</code></li>
<li>将指定分支合并到当前分支：<code>git merge (branch_name)</code></li>
<li>删除分支：<code>git branch -d (branch_name)</code> ，删除没有合并的分支要用-D</li>
<li>不使用FastForward模式进行分支的合并（在历史上能看出做过合并，ff模式看不出来做了合并）：
<ul>
<li><code>git merge --no-ff -m "说明"&nbsp;(branch_name)</code></li>
</ul>
</li>
</ul>
<hr>
<h3> 暂存</h3>
<ul>
<li>把工作现场临时储存起来：<code>git stash</code></li>
<li>恢复工作现场：<code>git stash apply</code></li>
<li>将存档从stash中删除：<code>git stash drop</code></li>
<li>恢复工作现场并将存档从stash中删除：<code>git stash pop</code></li>
<li>列出所有stash内容：<code>git stash list</code></li>
</ul>
<hr>
<h3> 远程服务器</h3>
<ul>
<li>查看远程库的信息：<code>git remote (-v)</code></li>
<li>将master分支推送至服务器origin上的master：<code>git push origin master</code></li>
<li>将dev分支推送至服务器origin上的test：<code>git push origin dev:test</code></li>
</ul>
<hr>
<h3> 标签</h3>
<ul>
<li>给指定commit创建标签：<code>git tag ()</code> 默认为HEAD</li>
<li>指定标签信息：<code>git tag -a -m "balabala"</code></li>
<li>使用PGP签名标签：<code>git tag -s -m "balabala"</code></li>
<li>查看所有标签：<code>git tag</code></li>
<li>删除标签： <code>git tag -d</code></li>
<li>将标签推送到服务器：<code>git push origin</code></li>
<li>将所有标签推送到服务器：<code>git push origin --tags</code></li>
<li>删除远程服务器上的一个标签：<code>git push origin :/refs/tags/</code></li>
</ul>
<hr>
<h3> 初始化相关</h3>
<ul>
<li>生成ssh密钥：<code>ssh-keygen -t rsa -C "lztsmail@gmail.com"</code></li>
<li>添加远程库：<code>git remote add origin git@github.com/xxx</code></li>
<li><code>git pull origin master --allow-unrelated-histories</code></li>
<li><code>git push -u origin master</code></li>
</ul>
<hr>
<h3> 设置基本信息</h3>
<ul>
<li><code>git config --global user.name "你的名字或昵称"</code></li>
<li><code>git config --global user.email "你的邮箱"</code></li>
</ul>
<hr>
<h3> 配置别名</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> Git 相关概念：基础篇 <sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></h2><a class="footnote-anchor" id="footnote-ref1">
</a><div class="hint-container tip"><a class="footnote-anchor" id="footnote-ref1">
<p class="hint-container-title">提示</p>
</a><p><a class="footnote-anchor" id="footnote-ref1">强烈建议使用该线上教程 </a><a href="https://learngitbranching.js.org/?demo=&amp;locale=zh_CN" target="_blank" rel="noopener noreferrer">Learn Git Branching</a> 了解 git 的各种概念，本文后半部分为该线上教程的文字版本，供读者参考。</p>
</div>
<h3> Git Commit</h3>
<p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，<strong>就像是把整个目录复制</strong>，然后再粘贴一样，但比复制粘贴优雅许多！</p>
<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并<strong>不会盲目地复制整个目录</strong>。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并<strong>把所有的差异打包到一起作为一个提交记录</strong>。</p>
<p>Git <strong>还保存了提交的历史记录</strong>。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。</p>
<p>关于提交记录太深入的东西咱们就不再继续探讨了，现在你可以把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换！</p>
<h3> Git Branch</h3>
<p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：</p>
<blockquote>
<p>早建分支！多用分支！</p>
</blockquote>
<p>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>
<p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/FjFb0t.gif" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Git Merge</h3>
<p>我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>
<p>咱们先来看一下第一种方法 ——&nbsp;<code>git merge</code>。在 Git 中合并两个分支时会产生一个特殊的提交记录，<strong>它有两个父节点</strong>。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”</p>
<p>右图为将main 与 bugFix 进行合并，main移动指针指向新的结果。之后可以 <code>git checkout bugFix; git merge main</code> 会将bugFix指针直接移动到 C4，因为 C4 继承于 C2，已经包含了 C2的所有信息。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/0c2tyq.png" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Git Rebase</h3>
<p>第二种合并分支的方法是&nbsp;<code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<p>还是准备了两个分支；注意当前所在的分支是 bugFix（星号标识的是当前分支）</p>
<p>我们想要把 bugFix 分支里的工作直接移到 main 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。</p>
<p>咱们这次用&nbsp;<code>git rebase</code>&nbsp;实现此目标</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Ot8Kis.gif" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>怎么样？！现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。</p>
<p>注意，提交记录 C3 依然存在（树上那个半透明的节点），而 C3' 是我们 Rebase 到 main 分支上的 C3 的副本。</p>
<h2> Git 相关概念：在提交树上移动</h2>
<p>在接触 Git 更高级功能之前，我们有必要先学习在你项目的提交树上前后移动的几种方法。</p>
<h3> HEAD</h3>
<p>我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是<strong>指向你正在其基础上进行工作的提交记录</strong>。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>如果想看 HEAD 指向，可以通过&nbsp;<code>cat .git/HEAD</code> 查看， 如果 HEAD 指向的是一个引用，还可以用&nbsp;<code>git symbolic-ref HEAD</code>&nbsp;查看它的指向。</p>
</div>
<h3> 分离的 HEAD</h3>
<p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：</p>
<p>HEAD -&gt; main -&gt; C1</p>
<p>HEAD 指向 main， main 指向 C1</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Vu5FYW.png" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 相对引用</h3>
<p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用&nbsp;<code>git log</code>&nbsp;来查查看提交记录的哈希值。</p>
<p>并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是&nbsp;<code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。舌头都快打结了吧...</p>
<p>比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code>&nbsp;而不是上面的一长串字符。</p>
<p>正如我前面所说，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如&nbsp;<code>bugFix</code>&nbsp;分支或&nbsp;<code>HEAD</code>）开始计算。</p>
<p>相对引用非常给力，这里我介绍两个简单的用法：</p>
<ul>
<li>使用&nbsp;<code>^</code>&nbsp;向上移动 1 个提交记录</li>
<li>使用&nbsp;<code>~&lt;num&gt;</code>&nbsp;向上移动多个提交记录，如&nbsp;<code>~3</code></li>
</ul>
<p>首先看看操作符 (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。</p>
<p>所以&nbsp;<code>main^</code>&nbsp;相当于“<code>main</code>&nbsp;的父节点”。</p>
<p><code>main^^</code>&nbsp;是&nbsp;<code>main</code>&nbsp;的第二个父节点</p>
<p>现在咱们切换到 main 的父节点</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/oHYiQr.png" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> “~”操作符</h3>
<p>如果你想在提交树中向上移动很多步的话，敲那么多&nbsp;<code>^</code>&nbsp;貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符&nbsp;<code>~</code>。</p>
<p>该操作符后面可以跟一个数字（可选，不跟数字时与&nbsp;<code>^</code>&nbsp;相同，向上移动一次），指定向上移动多少次。咱们还是通过实际操作看一下吧</p>
<h3> 强制修改分支位置</h3>
<p>你现在是相对引用的专家了，现在用它来做点实际事情。</p>
<p>我使用相对引用最多的就是移动分支。可以直接使用&nbsp;<code>-f</code>&nbsp;选项让分支指向另一个提交。例如:</p>
<p><code>git branch -f main HEAD~3</code></p>
<p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p>
<p>这就对了! 相对引用为我们提供了一种简洁的引用提交记录&nbsp;<code>C1</code> 的方式， 而&nbsp;<code>-f</code>&nbsp;则容许我们将分支强制移动到那个位置。</p>
<h2> Git 相关概念：撤销变更</h2>
<p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>
<p>主要有两种方法用来撤销变更 —— 一是&nbsp;<code>git reset</code>，还有就是&nbsp;<code>git revert</code>。接下来咱们逐个进行讲解。</p>
<h3> Git Reset</h3>
<p><code>git reset</code>&nbsp;通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code>&nbsp;向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p>
<p><code>git reset HEAD~1</code> ←右侧执行的指令</p>
<p>Git 把 main 分支移回到&nbsp;<code>C1</code>；现在我们的本地代码库根本就不知道有&nbsp;<code>C2</code>&nbsp;这个提交了。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/FATkLc.png" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Git Revert</h3>
<p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用&nbsp;<code>git revert</code>。</p>
<p><code>git revert HEAD</code> ← 右侧执行的指令</p>
<p>奇怪！在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录&nbsp;<code>C2'</code>&nbsp;引入了<strong>更改</strong>&nbsp;—— 这些更改刚好是用来撤销&nbsp;<code>C2</code>&nbsp;这个提交的。也就是说&nbsp;<code>C2'</code>&nbsp;的状态与&nbsp;<code>C1</code>&nbsp;是相同的。</p>
<p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/dMf2k4.png" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> Git 相关概念：整理提交记录</h2>
<p>到现在我们已经学习了 Git 的基础知识 —— 提交、分支以及在提交树上移动。 这些概念涵盖了 Git 90% 的功能，同样也足够满足开发者的日常需求</p>
<p>然而, 剩余的 10% 在处理复杂的工作流时(或者当你陷入困惑时）可能就显得尤为重要了。接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。</p>
<p>看起来挺复杂, 其实是个很简单的概念。</p>
<h3> Git Cherry-pick</h3>
<p>本系列的第一个命令是&nbsp;<code>git cherry-pick</code>, 命令形式为:</p>
<ul>
<li><code>git cherry-pick &lt;提交号&gt;...</code></li>
</ul>
<p>如果你<strong>想将一些提交复制到当前所在的位置</strong>（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢&nbsp;<code>cherry-pick</code>，因为它特别简单。</p>
<p>这里有一个仓库, 我们想将&nbsp;<code>side</code>&nbsp;分支上的工作复制到&nbsp;<code>main</code>&nbsp;分支，你立刻想到了之前学过的&nbsp;<code>rebase</code>&nbsp;了吧？但是咱们还是看看&nbsp;<code>cherry-pick</code>&nbsp;有什么本领吧。</p>
<p>这就是了！我们只需要提交记录&nbsp;<code>C2</code>&nbsp;和&nbsp;<code>C4</code>，所以 Git 就将被它们抓过来放到当前分支下了。 就是这么简单!</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/UkaXXr.gif" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 交互式的 rebase</h3>
<p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p>
<p>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>
<p>交互式 rebase 指的是使用带参数&nbsp;<code>--interactive</code>&nbsp;的 rebase 命令, 简写为&nbsp;<code>-i</code></p>
<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>
<p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。 考虑到课程的初衷，我弄了一个对话框来模拟这些操作。</p>
<p>当 rebase UI界面打开时, 你能做3件事:</p>
<ul>
<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>
<li>删除你不想要的提交（通过切换&nbsp;<code>pick</code>&nbsp;的状态来完成，关闭就意味着你不想要这个提交记录）</li>
<li>合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。</li>
</ul>
<p>接下来咱们看个实例</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/y9HpbZ.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> Git 相关概念：一些小技巧</h2>
<h3> 本地栈式提交</h3>
<p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>
<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>
<p>最后就差把&nbsp;<code>bugFix</code>&nbsp;分支里的工作合并回&nbsp;<code>main</code>&nbsp;分支了。你可以选择通过 fast-forward 快速合并到&nbsp;<code>main</code>&nbsp;分支上，但这样的话&nbsp;<code>main</code>&nbsp;分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>
<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>
<ul>
<li><code>git rebase -i</code></li>
<li><code>git cherry-pick</code></li>
</ul>
<p>来达到目的。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/d4WhjT.png" alt="" height="300" loading="lazy"> &nbsp;<br>
<img src="http://timpcfan-site.cdn.bcebos.com/imgs/uOu6XQ.png" alt="" height="300" loading="lazy"></p>
<h3> 提交的技巧 #1</h3>
<p>接下来这种情况也是很常见的：你之前在&nbsp;<code>newImage</code>&nbsp;分支上进行了一次提交，然后又基于它创建了&nbsp;<code>caption</code>&nbsp;分支，然后又提交了一次。</p>
<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下&nbsp;<code>newImage</code>&nbsp;中图片的分辨率，尽管那个提交记录并不是最新的了。</p>
<p>我们可以通过下面的方法来克服困难：</p>
<ul>
<li>先用&nbsp;<code>git rebase -i</code>&nbsp;将提交重新排序，然后把我们想要修改的提交记录挪到最前</li>
<li>然后用&nbsp;<code>git commit --amend</code>&nbsp;来进行一些小修改</li>
<li>接着再用&nbsp;<code>git rebase -i</code>&nbsp;来将他们调回原来的顺序</li>
<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li>
</ul>
<p>当然完成这个任务的方法不止上面提到的一种（我知道你在看 cherry-pick 啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。 最后有必要说明一下目标状态中的那几个<code>'</code>&nbsp;—— 我们把这个提交移动了两次，每移动一次会产生一个&nbsp;<code>'</code>；而 C2 上多出来的那个是我们在使用了 amend 参数提交时产生的，所以最终结果就是这样了。</p>
<p>也就是说，我在对比结果的时候只会对比提交树的结构，对于&nbsp;<code>'</code>&nbsp;的数量上的不同，并不纳入对比范围内。只要你的&nbsp;<code>main</code>&nbsp;分支结构与目标结构相同，我就算你通过。</p>
<h3> 提交的技巧 #2</h3>
<p><em>如果你还没有完成“提交的技巧 #1”（前一关）的话，请先通过以后再来！</em></p>
<p>正如你在上一关所见到的，我们可以使用&nbsp;<code>rebase -i</code>&nbsp;对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用&nbsp;<code>--amend</code>&nbsp;修改它，然后把它们重新排成我们想要的顺序。</p>
<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看&nbsp;<code>git cherry-pick</code>&nbsp;是怎么做的吧。</p>
<h3> Git Tags</h3>
<p>相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p>
<p>你可能会问了：有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>
<p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>
<p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<p>咱们来看看标签到底是什么样。</p>
<p>咱们先建立一个标签，指向提交记录&nbsp;<code>C1</code>，表示这是我们 1.0 版本。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>很容易吧！我们将这个标签命名为&nbsp;<code>v1</code>，并且明确地让它指向提交记录&nbsp;<code>C1</code>，如果你不指定提交记录，Git 会用&nbsp;<code>HEAD</code>&nbsp;所指向的位置。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/B84z6y.png" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Git Describe</h3>
<p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是&nbsp;<code>git describe</code>！</p>
<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用&nbsp;<code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>
<p><code>git describe</code>&nbsp;的语法是：</p>
<p><code>git describe &lt;ref&gt;</code></p>
<p><code>&lt;ref&gt;</code>&nbsp;可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p>
<p>它输出的结果是这样的：</p>
<p><code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code></p>
<p><code>tag</code>&nbsp;表示的是离&nbsp;<code>ref</code>&nbsp;最近的标签，&nbsp;<code>numCommits</code>&nbsp;是表示这个&nbsp;<code>ref</code>&nbsp;与&nbsp;<code>tag</code>&nbsp;相差有多少个提交记录，&nbsp;<code>hash</code>&nbsp;表示的是你所给定的&nbsp;<code>ref</code>&nbsp;所表示的提交记录哈希值的前几位。</p>
<p>当&nbsp;<code>ref</code>&nbsp;提交记录上有某个标签时，则只输出标签名称</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/nlsthb.png" alt="" height="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 多分支 rebase</h3>
<p>哥们儿，我们准备了很多分支！咱们把这些分支 rebase 到 main 上吧。</p>
<p>但是你的领导给你提了点要求 —— 他们希望得到有序的提交历史，也就是我们最终的结果应该是&nbsp;<code>C6'</code>&nbsp;在&nbsp;<code>C7'</code>&nbsp;上面，&nbsp;<code>C5'</code>&nbsp;在&nbsp;<code>C6'</code>&nbsp;上面，依此类推。</p>
<p>即使你搞砸了也没关系，用&nbsp;<code>reset</code>&nbsp;命令就可以重新开始了。记得看看我们提供的答案，看你能否使用更少的命令来完成任务！</p>
<h3> 选择父提交记录</h3>
<p>操作符&nbsp;<code>^</code>&nbsp;与&nbsp;<code>~</code>&nbsp;符一样，后面也可以跟一个数字。</p>
<p>但是该操作符后面的数字与&nbsp;<code>~</code>&nbsp;后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>
<p>Git 默认选择合并提交的“第一个”父提交，在操作符&nbsp;<code>^</code>&nbsp;后跟一个数字可以改变这一默认行为。</p>
<p>废话不多说，举个例子。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/GzTuD6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/5UVgNg.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p><a href="https://learngitbranching.js.org/?demo=&amp;locale=zh_CN" target="_blank" rel="noopener noreferrer">Learn Git Branching</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>CSS 笔记</title>
      <link>https://newzone.top/code/frontend/css.html</link>
      <guid>https://newzone.top/code/frontend/css.html</guid>
      <source url="https://newzone.top/rss.xml">CSS 笔记</source>
      <description>相关信息 整理了一些学习 CSS 时的笔记。 CSS 布局之 position 篇 [1] 提示 position 属性用来描述 HTML 元素如何在文档流中定位。</description>
      <category>笔记</category>
      <category>前端</category>
      <pubDate>Mon, 14 Aug 2023 09:07:38 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>整理了一些学习 CSS 时的笔记。</p>
</div>
<h2> CSS 布局之 position 篇 <sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></h2><a class="footnote-anchor" id="footnote-ref1">
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p><code>position</code> 属性用来描述 HTML 元素如何在文档流中定位。</p>
</div>
</a><h3><a class="footnote-anchor" id="footnote-ref1"></a> position 属性</h3>
<p>position 属性的值有：</p>
<ul>
<li>static：（默认值）根据正常文档流放置。</li>
<li>relative：基于正常文档流的位置使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行偏移。</li>
<li>absolute：将元素<strong>移出文档流</strong>，在<a href="/code/frontend/css_containing_block.html" target="blank"><mark>包含块</mark></a>内使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行放置。</li>
<li>fixed：将元素<strong>移出文档流</strong>，在<strong>整个视图区域</strong>内使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行放置。</li>
<li>sticky：基于正常文档流的位置放置，并且在滚动屏幕时能粘在画面内，使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行偏移。</li>
</ul>
<div class="hint-container warning">
<p class="hint-container-title">巨大的坑</p>
<p>注意：<strong>包含块</strong>不一定就是直接的父容器！详情请查阅<a href="/code/frontend/css_containing_block.html" target="blank">文档</a>。</p>
</div>
<h3> 指定位置</h3>
<p><code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性用于指定元素的最终位置。</p>
<div class="hint-container info">
<p class="hint-container-title">这里拿 absolute 模式来举例。</p>
</div>
<ul>
<li>top: 元素上边界距离包含块的相对距离。</li>
<li>right: 元素右边界距离包含块的相对距离。</li>
<li>bottom: 元素下边界距离包含块的相对距离。</li>
<li>left: 元素左边界距离包含块的相对距离。</li>
</ul>
<iframe class="interactive is-default-height" height="370px" width="100%" src="https://interactive-examples.mdn.mozilla.net/pages/css/position.html" title="MDN Web Docs Interactive Example" loading="lazy"></iframe>
<h2> CSS 布局之 Flexbox 篇（基础） <sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup></h2><a class="footnote-anchor" id="footnote-ref2">
</a><h3><a class="footnote-anchor" id="footnote-ref2"></a> 介绍</h3>
<p>Flexbox 是Flexible Box Module.&nbsp;一种布局模型，可以轻松控制 html 元素 之间的空间分布和对齐方式。</p>
<p>Flexbox 控制一次仅在一维（行或列）中的定位。对于二维控件，CSS Grid Layout 应运而生。</p>
<p>给定以下模板：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述 div 的默认行为，尊重正常的 html 文档流，是从上到下、从左到右呈现并占据整个正文宽度，因为它的display属性默认为block.</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/4USqRq.jpg" alt="4USqRq" height="300" tabindex="0" loading="lazy"><figcaption>4USqRq</figcaption></figure>
<h3> 弹性item</h3>
<p>当<code>display: flex</code>应用于<code>.container div</code> 时，所有直接子 <code>div</code> 变为<code>flex-items</code>，并获得新的行为：</p>
<ul>
<li>它们将显示在一行中，因为 <code>flex-direction</code> 默认为 <code>row</code></li>
<li>它们将从左到右显示</li>
<li>项目<strong>不会拉伸</strong>以适应整个宽度（主轴），但它们会收缩以做到这一点。<br>
<img src="http://timpcfan-site.cdn.bcebos.com/imgs/AsUQoe.gif" alt="AsUQoe" loading="lazy"></li>
<li>项目<strong>拉伸</strong>以适应交叉轴（本例中的高度）。</li>
<li>如果物品有不同的高度，它们将伸展到最高的一个高度</li>
<li>flex-basis默认为auto（项目宽度将由其内容设置）</li>
<li>flex-wrap默认为nowrap（如果容器的宽度不足以容纳物品，它们不会包装，而是会溢出）</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>在主轴上收缩（收缩成自身宽度），在交叉轴上拉伸（拉伸成最高那个）。</p>
</div>
<h3> 弹性容器</h3>
<ul>
<li>display: flex使容器扩展可用的整个宽度。与flex相反display: inline-flex，它使容器折叠到内容的宽度。</li>
</ul>
<h3> flex-direction</h3>
<p>一旦声明为 flex 容器，该元素就可以被认为是两个轴。主轴，由flex-direction属性定义。和交叉轴，它垂直于第一个。</p>
<p>该属性有四个值flex-direction：<code>row</code>、 <code>column</code>、<code>row-reverse</code>、 <code>columncolumn-reverse</code></p>
<p>默认值为row，它设置主轴水平，从左到右，横轴垂直截取它，从上到下。类似地，该column值设置垂直轴，从上到下，交叉轴从左到右。两个选项的reverse属性都将主轴反转 180°。交叉轴保持不变。</p>
<p>这些值的弹性项目行为可以在下面观察到：</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/oibRlg.gif" alt="oibRlg" tabindex="0" loading="lazy"><figcaption>oibRlg</figcaption></figure>
<h3> flex-wrap</h3>
<p>flex-wrap是当容器中的空间不足以容纳所有弹性项目时处理弹性项目的属性。</p>
<p>默认情况下flex-wrap设置为nowrap，这意味着如果容器不能以原始宽度容纳一行中的项目，它们将缩小以适应。如果由于某种原因它们无法收缩，那么它们会溢出容器。</p>
<p>通过为项目设置 300px 宽度，该nowrap选项会输出以下结果：</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/yuHKj4.png" alt="yuHKj4" height="300" tabindex="0" loading="lazy"><figcaption>yuHKj4</figcaption></figure>
<p>其中，每个项目都缩小到大约 70px 以适应容器。</p>
<p>当属性更新为 时wrap，项目的宽度现在实际上将具有其原始值 300 像素。当第一行的宽度不足以容纳 300 像素时，该项目不会溢出容器，而是换行到新行。每一行都应该被认为是一个单独的弹性容器。一个容器中的空间分布不会影响相邻的其他容器。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/HqmnPV.png" alt="HqmnPV" height="300" tabindex="0" loading="lazy"><figcaption>HqmnPV</figcaption></figure>
<p>另一种选择是wrap-reverse，它反转交叉轴。flex-direction由属性从上到下设置，wrap-reverse将其转换为从下到上。</p>
<h3> 弹性流</h3>
<p><code>flex-direction</code>并且<code>flex-wrap</code>可以在单个属性中声明：<code>flex-flow: [direction] [wrap]</code></p>
<h3> 对齐</h3>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/invnoF.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在 Flexbox 中，项目沿轴的对齐和空间分布可以通过四个属性来控制 ：</p>
<ul>
<li>justify-content：对齐主轴上的所有项目</li>
<li>align-items：对齐交叉轴上的所有项目</li>
<li>align-self：在交叉轴上对齐单个项目</li>
<li>align-content: 控制交叉轴上弯曲线之间的空间</li>
</ul>
<h3> 弹性盒尺寸</h3>
<p>项目的大小和灵活性可以通过三个属性来控制flex-grow、flex-shrink和flex-basis。这三个都作用于主轴。</p>
<ul>
<li>flex-grow: 如果有多余的空间，每个项目应该如何放大</li>
<li>flex-shrink: 如果没有足够的空间，每个项目应该如何减少</li>
<li>flex-basis: 在设置上面两个属性之前，项目应该是什么大小</li>
</ul>
<h4> flex-grow 弹性成长</h4>
<p>此属性的flex grow factor设置是处理项目大小相对于彼此的比率。</p>
<p>默认值为 0，表示如果有可用空间，则将其放在最后一项之后。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/55rRLZ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在上面的示例中，direction设置为row，并且每个弹性项目width都设置为60px。由于容器很980px宽，因此有680px可用空间。该空间称为positive free space。</p>
<p>通过设置flex-grow为1，正的可用空间量在弹性项目之间平均分配。每个项目的宽度将增加136px，总计196px。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/5trUDz.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>通过<code>flex-grow: 2</code>应用于第三个项目，它获得的可用正可用空间量是<code>286px</code>其余项目的两倍，<code>173px</code>。</p>
<p>下图显示了<code>flex-grow</code>属性设置为其内容值的项目。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/1ftKa2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> flex-shrink 弹性收缩</h4>
<p>flex-shrink处理项目大小，当没有足够的可用空间将它们全部放入容器中时。因此，它negative free space通过缩小项目来划分项目。</p>
<p>下一张图片显示了980px装有五个300px宽物品的容器。由于没有空间容纳1500px所需，默认flex shrink factor值1使每个项目均匀收缩到196px。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Y3Pm8q.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>通过<code>flex-shrink: 2</code>为第三项设置比率，它会比其他项小两倍。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Wcu0xX.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本节中的最后一张图片显示了将其内容值保存为 flex 收缩率的每个项目。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/uAEXro.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> flex-basis 弹性基础</h4>
<p>flex-basis是在实际设置可用空间之前检查每个项目应具有的大小的属性。默认值为auto，并且项目宽度由width属性显式设置，或者采用内容宽度。它还接受像素值。</p>
<p>下面的 gif 显示了一个800px宽容器和五个设置为flex-basis: 160px. 这告诉浏览器：理想情况下，有足够的空间来放置所有项目，尊重它们的160px宽度，并且没有正/负的可用空间。如果没有足够的空间，由于flex-shrink默认为1，所有项目都被均匀收缩。如果有多余的空间，则flex-grow默认为0，并且空白空间位于最后一项之后。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/SKURrp.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下一个 gif 显示项目 1 设置为<code>flex-shrink: 10</code>，项目 4 设置为<code>flex-grow: 10</code>。对于负的可用空间，项目 1 的宽度减少了 10 倍。对于正的可用空间，项目 4 的宽度是其他项目的 10 倍。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/B184OW.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>flex-basis</code>也接受 value&nbsp;<code>content</code>，无论<code>width</code>是否设置，计算可用空间的宽度都是项目的内容。如果您不想考虑该计算的项目宽度，请将基础设置为<code>0</code>。</p>
<h4> flex 弹性</h4>
<p>flex 是 <code>flex-grow</code>, <code>flex-shrink</code>, <code>flex-basis</code> 的简写.</p>
<p>它接受以下预定义值：</p>
<ul>
<li><code>initial</code>: 重置为 flexbox 默认值，与 <code>flex: 0 1 auto</code> 相同</li>
<li><code>auto</code>: flex-items 可以根据需要增长/缩小，与 <code>flex: 1 1 auto</code> 相同</li>
<li><code>none</code>: 使项目不灵活，与 <code>flex: 0 0 auto</code> 相同</li>
<li><code>flex: 1</code>: flex-items 具有增长/收缩的能力并且flex-basis设置为零，与 <code>flex: 1 1 0</code> 相同</li>
</ul>
<h2> CSS 布局之 Flexbox 篇（扩展） <sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup></h2><a class="footnote-anchor" id="footnote-ref3">
</a><h3><a class="footnote-anchor" id="footnote-ref3"></a> 几个例子</h3>
<h4> 例子：居中对齐</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/K3PDPP.png" alt="K3PDPP" tabindex="0" loading="lazy"><figcaption>K3PDPP</figcaption></figure>
<h4> 例子：偏移</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/9jnlas.png" alt="9jnlas" tabindex="0" loading="lazy"><figcaption>9jnlas</figcaption></figure>
<h4> 例子：反序</h4>
<p>让所有项反序排列</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>此外还有 column-reverse  为垂直反序。</p>
</div>
<h3> flexbox的对齐</h3>
<p>关于Flexbox的对齐，最重要的是理解坐标轴。有两个轴，“主轴”和“交叉轴”。这两个轴代表什么取决于Flexbox排列的方向。比如，如果将Flexbox的方向设置为<code>row</code>，则主轴就是横轴， 而交叉轴就是纵轴。</p>
<p>反之，如果Flexbox的方向是<code>column</code>，则主轴就是纵轴，而交叉轴为横轴。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/OioNsa.png" alt="OioNsa" tabindex="0" loading="lazy"><figcaption>OioNsa</figcaption></figure>
<h4> 沿着交叉轴对齐</h4>
<p>设置的属性：</p>
<ul>
<li>align-items：设置容器内所有item沿交叉轴对齐的方式（对容器内元素）</li>
<li>align-self：针对内部元素，设置特定的沿交叉轴对齐的方式（对自己）</li>
</ul>
<p>对齐的方式：</p>
<ul>
<li>flex-start: 把元素的对齐设置为flex-start，可以让元素从Flexbox父元素的起始边 开始。</li>
<li>flex-end: 把元素的对齐设置为flex-end，会沿Flexbox父元素的末尾对齐该元素。</li>
<li>center: 把元素放在Flexbox元素的中间。</li>
<li>baseline: 让Flexbox元素中的所有项沿基线对齐。</li>
<li>stretch: 让Flexbox中的所有项(没交叉轴)拉伸至与父元素一样大</li>
</ul>
<h4> 沿着主轴对齐</h4>
<p>设置的属性：</p>
<ul>
<li>justify-content：设置容器内所有item沿主轴的对齐方式</li>
</ul>
<p>对齐的方式：</p>
<ul>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
<li>space-between：设置如何处理空白，将空白分配到元素之间</li>
<li>space-around：设置如何处理空白，将空白分配到元素两边</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Iqs9fg.png" alt="Iqs9fg" tabindex="0" loading="lazy"><figcaption>Iqs9fg</figcaption></figure>
<h3> flex属性</h3>
<p>前面已经给伸缩项(flex-item)定义过宽度了。除了width，还可以通过flex属性来定义宽 度，或者叫“伸缩性”(flexiness)。再看另一个例子，同样的标记，但CSS有所不同:</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的flex实际上是三个属性合体的简写:flex-grow、flex-shrink和flex-basis。 关于这三个属性的详细介绍，可以参考规范<a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="noopener noreferrer">原文</a>。不过， 规范还是建议大家使用flex这个简写属性，也就是我们这里用的这个，明白吗?</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于伸缩项，如果flex属性存在(且浏览器支持)，<strong>则使用它的值控制元素的大小，忽略宽度和高度值的设置</strong>，即使它们的声明位于flex声明之后，也会被忽略。下面分别看看这三个 属性。</p>
<ul>
<li>flex-grow(传给flex的第一个值)是相对于其他伸缩项，当前伸缩项在空间允许的情况下可以伸展的量。</li>
<li>flex-shrink是在空间不够的情况下，当前伸缩项相对于其他伸缩项可以收缩的量。</li>
<li>flex-basis(传给flex的最后一个值)是伸缩项伸缩的基准值。</li>
</ul>
<p>虽然只写<code>flex: 1</code>也没问题，但还是建议大家把三个值写全。这样才能更清楚地表明你想干什么。比如<code>flex: 1 2 auto</code>的意思是在有空间的情况下可以伸展1部分，在空间不足时可以收缩1部分，而<strong>基准大小是内容的固有宽度</strong>(即不伸缩的情况下内容的大小)。<br>
再试一个:<code>flex: 0 0 50px</code>的意思是，这个伸缩项既不伸也不缩，基准为50像素(即无论是否存在自由空间，都是50像素)。那么<code>flex: 2 0 50%</code>呢?意思就是会多占用两个可用空间， 不收缩，基准为50%。但愿这几个例子能帮大家理解flex属性。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>将flex-shrink的值设置为0，flex-basis实际上就相当于最小宽度。</p>
</div>
<h2> CSS 布局之 Grid 篇 <sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup></h2><a class="footnote-anchor" id="footnote-ref4">
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/GwfRmw.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一个网格通常具有许多的<strong>列（column）<strong>与</strong>行（row）</strong>，以及行与行、列与列之间的间隙，这个间隙一般被称为<strong>沟槽（gutter）</strong>。</p>
</a><h3><a class="footnote-anchor" id="footnote-ref4"></a> 定义网格</h3>
<p>在一个父容器中使用：<code>display: grid;</code> ，将这个容器改为网格布局。</p>
<ul>
<li>初始状态：只有一列的网格，你的子项还是会像正常布局流那样从上往下排布。</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>grid-template-columns</code> 来定义多个列，每个参数代表一个列的宽度。可以使用 <code>fr</code> 这个单位来灵活定义网格的行与列的大小。这个单位表示了<strong>可用空间</strong>的一个比例。</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>同样的，使用 <code>grid-template-rows</code> 可以定义多个行 ，每个参数代表一个行的高度。</p>
</div>
<h4> 网格间隙</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 显式网格与隐式网格</h4>
<p>使用 <code>grid-template-columns</code> 与 <code>grid-template-rows</code> 定义的网络称为显式网格，而多余的内容则会继续往下填充到新的行的格子内，这些格子被称为隐式网格。</p>
<p>隐式网格的默认行/列大小是参数<code>auto</code> ，大小会根据放入的内容自动调整。也可以使用 <code>[grid-auto-rows](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-rows)</code>和<code>[grid-auto-columns](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-columns)</code>属性手动设定隐式网格的大小。</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 元素放置</h3>
<h4> 基于线的元素放置</h4>
<p>定义完网格之后，每行每列的边界（网格线的边缘）都有一个索引，可以使用这些线来定位放置元素。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/xHBtux.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>可以使用负数来进行倒数，但对于隐式网格来说 -1 不一定代表最后一条分界线。</p>
</div>
<h4> 使用 grid-template-areas 属性放置元素</h4>
<p>另一种往网格放元素的方式是用<code>[grid-template-areas](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-areas)</code>属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。</p>
<p>将之前基于线的元素放置代码删除（或者重新下载一份新的文件），然后加入以下 CSS 规则：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>grid-template-areas</code>属性的使用规则如下：</p>
<ul>
<li>你需要填满网格的每个格子</li>
<li>对于某个横跨多个格子的元素，重复写上那个元素<code>grid-area</code>属性定义的区域名字</li>
<li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li>
<li>一个连续的区域必须是一个矩形</li>
<li>使用<code>.</code>符号，让一个格子留空</li>
</ul>
<p>你可以在文件中尽情发挥你的想象来测试各种网格排版，比如把页脚放在内容之下，或者把侧边栏一直延伸到最底。这种直观的元素放置方式很棒，你在 CSS 中看到的就是实际会出现的排版效果。</p>
<h2> CSS 选择器</h2>
<table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>示例说明</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>.class</td>
<td>.intro</td>
<td>选择所有class="intro"的元素</td>
<td>1</td>
</tr>
<tr>
<td>#id</td>
<td>#firstname</td>
<td>选择所有id="firstname"的元素</td>
<td>1</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>选择所有元素</td>
<td>2</td>
</tr>
<tr>
<td>element</td>
<td>p</td>
<td>选择所有<code>&lt;p&gt;</code>元素</td>
<td>1</td>
</tr>
<tr>
<td>element,element</td>
<td>div,p</td>
<td>选择所有<code>&lt;div&gt;</code>元素和<code>&lt;p&gt;</code>元素</td>
<td>1</td>
</tr>
<tr>
<td>element&nbsp;element</td>
<td>div p</td>
<td>选择<code>&lt;div&gt;</code>元素内的所有<code>&lt;p&gt;</code>元素</td>
<td>1</td>
</tr>
<tr>
<td>element&gt;element</td>
<td>div&gt;p</td>
<td>选择所有父级是 <code>&lt;div&gt;</code> 元素的 <code>&lt;p&gt;</code> 元素（div的直接儿子，不包含孙子）</td>
<td>2</td>
</tr>
<tr>
<td>element+element</td>
<td>div+p</td>
<td>选择所有紧跟在 <code>&lt;div&gt;</code> 元素之后的第一个 <code>&lt;p&gt;</code> 元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute]</td>
<td>[target]</td>
<td>选择所有带有target属性元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>[target=-blank]</td>
<td>选择所有使用target="-blank"的元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td>[title~=flower]</td>
<td>选择标题属性包含单词"flower"的所有元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute</td>
<td>=language]</td>
<td>[lang</td>
<td>=en]</td>
</tr>
<tr>
<td>:link</td>
<td>a:link</td>
<td>选择所有未访问链接</td>
<td>1</td>
</tr>
<tr>
<td>:visited</td>
<td>a:visited</td>
<td>选择所有访问过的链接</td>
<td>1</td>
</tr>
<tr>
<td>:active</td>
<td>a:active</td>
<td>选择活动链接</td>
<td>1</td>
</tr>
<tr>
<td>:hover</td>
<td>a:hover</td>
<td>选择鼠标在链接上面时</td>
<td>1</td>
</tr>
<tr>
<td>:focus</td>
<td>input:focus</td>
<td>选择具有焦点的输入元素</td>
<td>2</td>
</tr>
<tr>
<td>:first-letter</td>
<td>p:first-letter</td>
<td>选择每一个<code>&lt;p&gt;</code>元素的第一个字母</td>
<td>1</td>
</tr>
<tr>
<td>:first-line</td>
<td>p:first-line</td>
<td>选择每一个<code>&lt;p&gt;</code>元素的第一行</td>
<td>1</td>
</tr>
<tr>
<td>:first-child</td>
<td>p:first-child</td>
<td>指定只有当<code>&lt;p&gt;</code>元素是其父级的第一个子级的样式。</td>
<td>2</td>
</tr>
<tr>
<td>:before</td>
<td>p:before</td>
<td>在每个<code>&lt;p&gt;</code>元素之前插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:after</td>
<td>p:after</td>
<td>在每个<code>&lt;p&gt;</code>元素之后插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:lang(language)</td>
<td>p:lang(it)</td>
<td>选择一个lang属性的起始值="it"的所有<code>&lt;p&gt;</code>元素</td>
<td>2</td>
</tr>
<tr>
<td>element1~element2</td>
<td>p~ul</td>
<td>选择p元素之后的每一个ul元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>a[src^="https"]</td>
<td>选择每一个src属性的值以"https"开头的元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>a[src$=".pdf"]</td>
<td>选择每一个src属性的值以".pdf"结尾的元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>a[src*="runoob"]</td>
<td>选择每一个src属性的值包含子字符串"runoob"的元素</td>
<td>3</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>选择每个p元素是其父级的第一个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父级的最后一个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择每个p元素是其父级的唯一p元素</td>
<td>3</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>选择每个p元素是其父级的唯一子元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择每个p元素是其父级的第二个子元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td>
<td>3</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择每个p元素是其父级的第二个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td>
<td>3</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择每个p元素是其父级的最后一个子级。</td>
<td>3</td>
</tr>
<tr>
<td>:root</td>
<td>:root</td>
<td>选择文档的根元素</td>
<td>3</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>选择每个没有任何子级的p元素（包括文本节点）</td>
<td>3</td>
</tr>
<tr>
<td>:target</td>
<td>#news:target</td>
<td>选择当前活动的#news元素（包含该锚名称的点击的URL）</td>
<td>3</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择每一个已启用的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择每一个禁用的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:checked</td>
<td>input:checked</td>
<td>选择每个选中的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择每个并非p元素的元素</td>
<td>3</td>
</tr>
<tr>
<td>::selection</td>
<td>::selection</td>
<td>匹配元素中被用户选中或处于高亮状态的部分</td>
<td>3</td>
</tr>
<tr>
<td>:out-of-range</td>
<td>:out-of-range</td>
<td>匹配值在指定区间之外的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:in-range</td>
<td>:in-range</td>
<td>匹配值在指定区间之内的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:read-write</td>
<td>:read-write</td>
<td>用于匹配可读及可写的元素</td>
<td>3</td>
</tr>
<tr>
<td>:read-only</td>
<td>:read-only</td>
<td>用于匹配设置 "readonly"（只读） 属性的元素</td>
<td>3</td>
</tr>
<tr>
<td>:optional</td>
<td>:optional</td>
<td>用于匹配可选的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:required</td>
<td>:required</td>
<td>用于匹配设置了 "required" 属性的元素</td>
<td>3</td>
</tr>
<tr>
<td>:valid</td>
<td>:valid</td>
<td>用于匹配输入值为合法的元素</td>
<td>3</td>
</tr>
<tr>
<td>:invalid</td>
<td>:invalid</td>
<td>用于匹配输入值为非法的元素</td>
<td>3</td>
</tr>
</tbody>
</table>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener noreferrer">position - CSS | MDN</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p><a href="https://blog.csdn.net/allway2/article/details/125083126" target="_blank" rel="noopener noreferrer">Flexbox 基础知识_allway2的博客-CSDN博客</a> <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote3" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox" target="_blank" rel="noopener noreferrer">弹性盒子 - 学习 Web 开发 | MDN</a> <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote4" class="footnote-item"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids#flexbox_%E7%BD%91%E6%A0%BC" target="_blank" rel="noopener noreferrer">网格 - 学习 Web 开发 | MDN</a> <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Vue.js 笔记</title>
      <link>https://newzone.top/code/frontend/vue.html</link>
      <guid>https://newzone.top/code/frontend/vue.html</guid>
      <source url="https://newzone.top/rss.xml">Vue.js 笔记</source>
      <description>提示 Vue (读音 /vjuː/，类似于 &amp;nbsp;view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 注意 本笔记整理较为混乱，建议使用官方文档学习。</description>
      <category>笔记</category>
      <category>前端</category>
      <pubDate>Mon, 14 Aug 2023 09:07:38 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>Vue (读音 /vjuː/，类似于 &nbsp;view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
</div>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>本笔记整理较为混乱，建议使用<a href="https://cn.vuejs.org" target="_blank" rel="noopener noreferrer">官方文档</a>学习。</p>
</div>
<h2> 相关学习资源</h2>
<ul>
<li>
<p><a href="https://v2.cn.vuejs.org" target="_blank" rel="noopener noreferrer">Vue2 文档</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org" target="_blank" rel="noopener noreferrer">Vue3 文档</a></p>
</li>
</ul>
<h2> vue 简介</h2>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/AYFU9u.png" alt="AYFU9u" tabindex="0" loading="lazy"><figcaption>AYFU9u</figcaption></figure>
<p>官方给 vue 的定位是前端框架，因为它提供了构建用户界面的一整套解决方案（俗称 vue 全家桶）</p>
<ul>
<li>vue（核心库）</li>
<li>vue-router（路由方案）</li>
<li>vuex（状态管理方案）</li>
<li>vue 组件库（快速搭建页面 UI 效果的方案）</li>
</ul>
<p>以及辅助 vue 项目开发的一系列工具：</p>
<ul>
<li>vue-cli（npm 全局包：一键生成工程化的 vue 项目 - 基于 webpack，大而全）</li>
<li>vite（npm 全局包：一键生成工程化的 vue 项目 - 小而巧）</li>
<li>vue-devtools（浏览器插件：辅助调试的工具）</li>
<li>vetur（vscode 插件：提供语法高亮和智能提示）</li>
</ul>
<h3> vue 的特性</h3>
<ul>
<li>数据驱动视图：
<ul>
<li>在使用了 vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构。</li>
<li>好处：当页面数据发生变化时，页面会自动重新渲染。</li>
<li>注：这是单向的数据绑定</li>
</ul>
</li>
<li>双向数据绑定
<ul>
<li>在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中。</li>
</ul>
</li>
</ul>
<h3> MVVM</h3>
<p>MVVM 是 vue 实现<strong>数据驱动视图</strong>和<strong>双向数据绑定</strong>的核心原理。它把每个 HTML 页面都拆分成了三个部分：</p>
<ul>
<li>View：当前页面所渲染的 DOM 结构</li>
<li>Model：当前页面渲染时所依赖的数据源</li>
<li>ViewModel：表示 vue 的实例，它是 MVVM 的核心，连接 View 与 Model</li>
</ul>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/mZ91S3.png" alt="mZ91S3" tabindex="0" loading="lazy"><figcaption>mZ91S3</figcaption></figure>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/qF2xKn.png" alt="qF2xKn" tabindex="0" loading="lazy"><figcaption>qF2xKn</figcaption></figure>
<h3> vue 的版本</h3>
<ul>
<li>2.x 版本是目前企业级项目开发中的主流版本</li>
<li>3.x 版本于 2020-09-19 发布，是未来企业级项目开发的趋势</li>
</ul>
<h3> 2.x 与 3.x 的对比</h3>
<ul>
<li>2.x 的绝大多数 API 在 3.x 中同样支持。</li>
<li>3.x 新增：组合式 API、多根节点组件、更好的 TypeScript 支持等</li>
<li>3.x 废弃：过滤器、不再支持off 和$once 实例方法等</li>
</ul>
<h2> vue 基础</h2>
<p>渐进式 JavaScript 框架</p>
<h3> 第一个 Vue 程序</h3>
<ol>
<li>导入开发版本的 Vue.js</li>
<li>创建 Vue 实例对象，设置 <code>el</code> 属性和 <code>data</code> 属性</li>
<li>使用简洁的模板语法把数据渲染到页面上</li>
</ol>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> el：挂载点</h4>
<ul>
<li>Vue 实例的作用范围？
<ul>
<li>作用在 <code>el</code> 作用的元素内部（包括任意层次的子标签）</li>
</ul>
</li>
<li>其值可以使用其他选择器吗？
<ul>
<li>可以，css 选择器都可以，但建议使用 ID 选择器</li>
</ul>
</li>
<li>是否可以设置其他的 dom 元素
<ul>
<li>可以，但建议使用 div 标签，因为没有其他样式</li>
</ul>
</li>
</ul>
<h4> data：数据对象</h4>
<ul>
<li>Vue 中用到的数据定义在 <code>data</code> 中</li>
<li><code>data</code> 中可以写复杂类型的数据</li>
<li>渲染复杂类型的数据时，遵守 js 的语法即可</li>
</ul>
<h2> vue 指令</h2>
<h3> v-text</h3>
<blockquote>
<p>设置标签的文本值（textContent）</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将标签中的文本，都使用 <code>data</code> 的指定属性替换。</p>
<p>可以在 v-text 中拼接字符串。</p>
<h3> v-html</h3>
<blockquote>
<p>设置标签的 innerHTML</p>
</blockquote>
<p>与 <code>v-text</code> 类似，不过如果设置的文本为 html 内容会进行解析。</p>
<h3> v-on 基础</h3>
<blockquote>
<p>为元素绑定事件</p>
</blockquote>
<p>语法：<code>v-on:事件名="方法名"</code> 或者 <code>@事件名="方法名"</code></p>
<ul>
<li>方法定义在 Vue 对象的 <code>methods</code> 属性中。</li>
<li>方法内部通过 <code>this</code> 关键字可以访问定义在 <code>data</code> 中的数据</li>
<li>如果是直接将方法写在属性的位置，则不需要 <code>this.xxx</code></li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note">
<p class="hint-container-title">注</p>
<p>注：事件名不需要写 <code>on</code> 因为左侧 <code>v-on</code> 已经有了</p>
</div>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-show</h3>
<blockquote>
<p>根据表达值的真假，切换元素的显示和隐藏</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-if</h3>
<blockquote>
<p>根据表达值的真假，切换元素的显示和隐藏（操纵 dom 元素）</p>
</blockquote>
<p>与 <code>v-show</code> 类似，但操纵的是 dom 元素（在 dom 中添加或删除该标签）</p>
<div class="hint-container info">
<p class="hint-container-title">如何选择 `v-show` 还是 `v-if` ？</p>
<p>频繁切换的元素使用 <code>v-show</code> ，否则使用 <code>v-if</code></p>
</div>
<h3> v-else</h3>
<blockquote>
<p>与 v-if 配合，切换元素的显示和隐藏</p>
</blockquote>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>前一兄弟元素必须有 &nbsp;<code>v-if</code>&nbsp; 或 &nbsp;<code>v-else-if</code>。</p>
</div>
<h3> v-else-if</h3>
<blockquote>
<p>与 v-if 配合，切换元素的显示和隐藏</p>
</blockquote>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-bind</h3>
<blockquote>
<p>设置元素的属性（比如：src, title, class）</p>
</blockquote>
<p>语法：<code>v-bind:属性名=表达式</code> 或 <code>:属性名=表达式</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>设置 <code>class</code> 属性时，建议使用对象的写法（第 4 个）</p>
</div>
<h3> v-for</h3>
<blockquote>
<p>根据数据生成列表结构</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>当列表的数据变化时，默认情况下，vue 会尽可能地复用已存在的 DOM 元素，从而提升渲染的性能。但这种默认的性能优化策略，会<strong>导致有状态的列表无法被正确更新</strong>。此时，需要为每项提供一个<strong>唯一</strong>的 key 属性（不能使用 index）：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h3> v-on 补充</h3>
<blockquote>
<p>传递自定义参数，事件修饰符</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解释</strong></p>
<ul>
<li>可以在 v-on 的属性中传入函数的参数</li>
<li>对于事件，可以使用修饰符</li>
</ul>
<p><strong>修饰符</strong>（文档：<a href="https://v2.cn.vuejs.org/v2/api/#v-on" target="_blank" rel="noopener noreferrer">https://v2.cn.vuejs.org/v2/api/#v-on</a>）</p>
<ul>
<li><code>.stop</code>&nbsp;- 调用 &nbsp;<code>event.stopPropagation()</code>。（阻止冒泡行为（内到外））</li>
<li><code>.prevent</code>&nbsp;- 调用 &nbsp;<code>event.preventDefault()</code>。（例如：阻止超链接的跳转）</li>
<li><code>.capture</code>&nbsp;- 添加事件侦听器时使用 capture 模式。（定义在外层组件上，以捕获的形式来触发事件（外到内））</li>
<li><code>.self</code>&nbsp;- 只当事件是从侦听器绑定的元素本身触发时才触发回调。（只有点他自己才会触发，而不受冒泡影响）</li>
<li><code>.{keyCode | keyAlias}</code>&nbsp;- 只当事件是从特定键触发时才触发回调。</li>
<li><code>.native</code>&nbsp;- 监听组件根元素的原生事件。</li>
<li><code>.once</code>&nbsp;- 只触发一次回调。</li>
<li><code>.left</code>&nbsp;- (2.2.0) 只当点击鼠标左键时触发。</li>
<li><code>.right</code>&nbsp;- (2.2.0) 只当点击鼠标右键时触发。</li>
<li><code>.middle</code>&nbsp;- (2.2.0) 只当点击鼠标中键时触发。</li>
<li><code>.passive</code>&nbsp;- (2.3.0) 以 &nbsp;<code>{ passive: true }</code>&nbsp; 模式添加侦听器</li>
</ul>
<h4> 事件对象 event</h4>
<p>在原生的 DOM 事件绑定中，可以在事件处理函数处，接收事件对象 event。同理，在 v-on 指令所绑定的事件处理函数中，同样可以接收到事件对象 event：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当传递参数时，event 对象将被覆盖掉，此时我们可以传递一个特殊的参数 <code>$event</code> 来表示原生的事件参数对象：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-model</h3>
<blockquote>
<p>获取和设置表单元素的值（<strong>双向数据绑定</strong>）</p>
</blockquote>
<ul>
<li>绑定的是 <code>input</code> 的 <code>value</code> 属性</li>
<li>之后无论是在表单中直接修改元素，还是在 js 中修改绑定的变量，都会使得两边的值都被改变</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> vue 过滤器（vue2.x 内容）</h2>
<p>过滤器（Filters）常用于文本的格式化。例如：hello → Hello</p>
<p>过滤器应该被添加在 JavaScript 表达式的尾部，由“管道符”进行调用，示例代码如下：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>过滤器可以用在两个地方：</p>
<ul>
<li>插值表达式（{{}}）</li>
<li>和 v-bind 属性绑定（:xxx）</li>
</ul>
<p>在创建 vue 实例期间，可以在 filters 节点中定义过滤器，示例代码：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 连续调用多个过滤器</h3>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 过滤器传参</h3>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 版本兼容性</h3>
<p>3.x 版本中取消掉了过滤器的特性，官方建议使用<a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">计算属性</a>或<strong>方法</strong>代替之。</p>
<h2> vue 组件基础</h2>
<p>如何创建 vite 项目：<a href="#vue-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA">vue 项目的创建</a></p>
<h3> 组件化开发思想</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>根据封装的思想，把页面上可重用的部分封装成组件，从而方便项目的开发和维护。</p>
</div>
<p>vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。</p>
<h3> vue 组件的构成</h3>
<p>每个.vue 组件都由 3 部分构成，分别是：</p>
<ul>
<li>template → 组件的模板结构（必需）</li>
<li>script → 组件的 JavaScript 行为（可选）</li>
<li>style → 组件的样式（可选）</li>
</ul>
<h4> 组件的 template 节点</h4>
<p>在组件 <code>&lt;template&gt;</code> 节点中，支持使用 vue 指令，来辅助渲染当前组件的 DOM 结构。</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>2.x 中，template 标签内仅支持单一根节点，3.x 中取消了该限制。</p>
</div>
<h4> 组件的 script 节点</h4>
<p>vue 规定：组件内 <code>&lt;script&gt;</code> 节点是可选的，开发者可以在 <code>&lt;script&gt;</code> 节点中封装组件的 JavaScript 业务逻辑。 <code>&lt;script&gt;</code> 节点的基本结构如下：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 组件中的 style 节点</h4>
<p>vue 规定：组件内的 <code>&lt;style&gt;</code> 节点是可选的，开发者可以在 <code>&lt;style&gt;</code> 节点中编写样式美化当前组件的 UI 结构。 <code>&lt;style&gt;</code> 节点的基本结构如下：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>也可以使用其他的语法，如 less 等，需要安装相应的依赖包：<code>npm install less -D</code></p>
</div>
<h3> 组件的注册</h3>
<p>组件之间可以进行相互的引用，例如：</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/SieVd6.png" alt="SieVd6" tabindex="0" loading="lazy"><figcaption>SieVd6</figcaption></figure>
<p>vue 中组件的引用原则：先注册后使用。</p>
<h4> 组件注册的两种方式</h4>
<p>vue 中注册组件的方式分为“全局注册”和“局部注册”两种，其中：</p>
<ul>
<li>全局注册：可以在全局任何一个组件内使用</li>
<li>局部注册：只能在当前注册的范围内使用</li>
</ul>
<h4> 全局注册组件</h4>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 局部注册组件</h4>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 组件注册时的命名</h4>
<ul>
<li>使用 kebab-case 命名法（短横线命名法，如 my-swiper ）
<ul>
<li>必须严格按照短横线名称进行使用</li>
</ul>
</li>
<li>使用 PascalCase 命名法（帕斯卡命名法或大驼峰法，如 MySwiper）
<ul>
<li>既可以严格按照帕斯卡名称使用，也可以转换成短横线名称使用</li>
</ul>
</li>
</ul>
<p><a href="http://xn--onq8a61aq0mvwxt6xwdcqzan82c.name" target="_blank" rel="noopener noreferrer">可以直接使用组件的.name</a> 属性</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 组件之间样式冲突问题</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>若在父组件中定义样式，会影响到子组件的样式，这样就很容易造成多个组件之间的样式冲突问题。导致组件冲突问题的根本原因是：</p>
<ol>
<li>单页面应用程序中，所有组件的 DOM 结构，都是基于<strong>唯一的 index.html 页面</strong>进行呈现的</li>
<li>每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素</li>
</ol>
</div>
<h4> 使用自定义属性解决样式冲突</h4>
<p>为每个组件<strong>分配唯一的自定义属性</strong>，在编写组件样式时，通过<strong>属性选择器</strong>来控制<strong>样式的作用域</strong>：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 使用 scoped 属性解决样式冲突</h4>
<p>手动分配自定义属性非常难以维护，可以使用 style 节点的 scoped 属性，vue 将自动分配自定义属性：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> /deep/ 样式穿透</h4>
<p>如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的。如果想让某些样式对子组件生效，可以使用 /deep/ 深度选择器。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 组件的 props</h3>
<p>为了提高组件的复用性，在封装 vue 组件时需要遵守如下的规则：</p>
<ul>
<li>组件的<strong>DOM 结构</strong>、<strong>style 样式</strong>要尽量复用</li>
<li>组件中<strong>要展示的数据</strong>，尽量由组件的使用者提供</li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>props 是组件的自定义属性，组件的使用者可以通过 props 把数据传递到子组件内部，供子组件内部进行使用。</p>
</div>
<p>例子：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>props 的<strong>作用</strong>：父组件通过 props<strong>向子组件传递要展示的数据</strong>。</p>
<p>props 的<strong>好处</strong>：提高了组件的<strong>复用性</strong>。</p>
<h4> 在组件中声明 props</h4>
<p>在封装 vue 组件时，可以把动态的数据项声明为 props 自定义属性。自定义属性可以在当前组件的模板结构中被直接使用。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlight-line">&nbsp;</div><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>props 中未声明的属性，如果传递会被忽视。</p>
</div>
<h4> 动态绑定 props 的值</h4>
<p>可以使用 v-bind 属性绑定的形式，为组件动态绑定 props 的值。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> props 的大小写命名</h4>
<p>组件中如果使用“camelCase（驼峰命名法）”声明了 props 属性的名称，则有两种方式为其绑定属性的值：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlight-line">&nbsp;</div><div class="highlight-line">&nbsp;</div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> props 验证</h4>
<p>在分装组件时对外界传递过来的 props 数据进行合法性的校验，从而防止数据不合法的问题。使用对象类型的 props 节点，可以对每个 prop 进行数据类型的校验：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Class 与 Style 绑定</h3>
<h4> 以三元表达式绑定 HTML 的 class</h4>
<p>可以使用三元表达式，动态地为元素绑定 class 的类名。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 以数组语法绑定 HTML 的 clas</h4>
<p>如果元素需要动态绑定多个 class 的类名，此时可以使用数组的语法格式。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 以对象语法绑定 HTML 的 class</h4>
<p>推荐使用此方法绑定 class。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 以对象语法绑定内联的 style</h4>
<p><code>:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式或短横线分隔（需要加引号）来命名：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 计算属性</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>计算属性本质上就是一个函数，它可以实时监听 data 中数据的变化，并 return 一个计算后的新值，供组件渲染 DOM 时使用。</p>
</div>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>调用时不需要加()，当作普通属性使用。</li>
<li>计算属性会缓存结果，只用依赖发生变化时才重新计算，因此性能比方法好。</li>
<li>使用场景：购物车金额等</li>
</ul>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 自定义事件（子传父）</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>在封装组件时，为了让<strong>组件的使用者</strong>可以<strong>监听到组件内状态的变化</strong>，此时需要用到<strong>组件的自定义事件</strong>。</p>
</div>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/6LdgWa.png" alt="6LdgWa" tabindex="0" loading="lazy"><figcaption>6LdgWa</figcaption></figure>
<h4> 自定义事件的使用</h4>
<p>在封装组件时：</p>
<ol>
<li><strong>声明</strong>自定义事件：定义自定义组件时，在 emits 节点中声明。</li>
<li><strong>触发</strong>自定义事件：</li>
</ol>
<p>在使用组件时：</p>
<ol>
<li><strong>监听</strong>自定义事件</li>
</ol>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 自定义事件传参</h4>
<p>在调用 <code>this.$emit()</code> 方法触发自定义事件时，可以通过<strong>第 2 个</strong>参数为自定义事件传参。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 组件上的 v-model</h3>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/hQRD5V.png" alt="hQRD5V" tabindex="0" loading="lazy"><figcaption>hQRD5V</figcaption></figure>
<p>v-model 是双向数据绑定指令，当需要<strong>维护组件内外数据的同步</strong>时，可以在组件上使用 v-model 指令。</p>
<hr>
<ul>
<li><strong>外界数据的变化</strong>会<strong>自动同步</strong>到 counter 组件中</li>
<li>counter 组件中数据的变化，也会<strong>自动同步到外界</strong>。</li>
</ul>
<h4> 在组件上使用 v-model 的步骤</h4>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/xb4bel.png" alt="xb4bel" tabindex="0" loading="lazy"><figcaption>xb4bel</figcaption></figure>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p><code>update:xxx</code> 表示让 v-model 去更新 xxx 的值，为后面传递的参数</p>
</div>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>此词条为 3.x 专属特性，请参考 <a href="https://cn.vuejs.org/guide/components/events.html#usage-with-v-model" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
</div>
<h2> vue 组件高级</h2>
<h3> watch 侦听器</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>watch 侦听器允许开发者监视数据的变化，从而<strong>针对数据的变化做特定的操作</strong>。例如，监听用户名的变化并发起请求，判断用户名是否可用。</p>
</div>
<p>开发者需要在 watch 节点下，定义自己的侦听器。实例代码如下：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 object 的形式定义 watch，可以设置更多的选项：</p>
<ul>
<li>immediate 选项：组件加载完立即调用一次</li>
<li>deep 选项：当监听的是一个对象，对象的属性值变化都会被监听（若只想监听一个属性，则不需要使用 deep 选项，而是使用 ‘info.username’ 这样的形式作为监听的变量）</li>
</ul>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 组件的生命周期</h3>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/hEeD6v.png" alt="hEeD6v" tabindex="0" loading="lazy"><figcaption>hEeD6v</figcaption></figure>
<p>组件的生命周期：组件从 <strong>创建</strong> → <strong>运行</strong>（渲染）→ <strong>销毁</strong> 的整个过程，强调的是一个时间段。</p>
<p>生命周期函数：</p>
<ol>
<li>created：当组件在内存中被创建完毕之后调用（唯一一次）</li>
<li>mounted：当组件被成功渲染到页面上之后调用（唯一一次）</li>
<li>unmounted：当组件被销毁完毕之后调用（例如 v-if 为 false）（唯一一次）</li>
<li>updated：组件被重新渲染（data 更新了）完毕之后调用（0 至多次）</li>
<li>beforeCreate 等：在上述周期之前执行。</li>
</ol>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>在实际开发中，created 是最常用的，比如进行 ajax 请求数据。若需要操作 dom 元素，则需要使用 mounted，因为 created 时组件还未被渲染。</p>
</div>
<h3> 组件之间的数据共享</h3>
<p>在项目开发中，组件之间的关系分为如下 3 种：</p>
<ol>
<li>父子关系</li>
<li>兄弟关系</li>
<li>后代关系</li>
</ol>
<h4> 父子组件的数据共享</h4>
<p>父子组件之间的数据共享又分为：</p>
<ol>
<li>父 → 子</li>
<li>子 → 父</li>
<li>父 ↔&nbsp; 子</li>
</ol>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/X1WYvK.png" alt="X1WYvK" tabindex="0" loading="lazy"><figcaption>X1WYvK</figcaption></figure>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/gRIHQf.png" alt="gRIHQf" tabindex="0" loading="lazy"><figcaption>gRIHQf</figcaption></figure>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/TktxFT.png" alt="TktxFT" tabindex="0" loading="lazy"><figcaption>TktxFT</figcaption></figure>
<h4> 兄弟组件的数据共享</h4>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/DWEqdA.png" alt="DWEqdA" tabindex="0" loading="lazy"><figcaption>DWEqdA</figcaption></figure>
<h5> 1. 安装 mit</h5>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5> 2. 创建公共的 EventBus 模块</h5>
<p>在项目中创建公共的 eventBus 模块如下：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 3. 在数据接收方自定义事件</h5>
<p>在数据接收方，调用 bus.on(’事件名称’, 事件处理函数） 方法注册一个自定义事件。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 4. 在数据发送方触发事件</h5>
<p>在数据发送方，调用 bus.emit(’事件名称’，要发送的数据) 方法触发自定义事件。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 后代关系组件之间的数据共享</h4>
<p>可以使用 provide 和 inject 实现后代组件之间的数据共享。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/5QQbjj.png" alt="5QQbjj" tabindex="0" loading="lazy"><figcaption>5QQbjj</figcaption></figure>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/dM8Wma.png" alt="dM8Wma" tabindex="0" loading="lazy"><figcaption>dM8Wma</figcaption></figure>
<p>上述的方法不是响应式的，改变了父组件的值，子孙组件没有变化，要使用 computed 函数修改：</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/WLpXE4.png" alt="WLpXE4" tabindex="0" loading="lazy"><figcaption>WLpXE4</figcaption></figure>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/gPCKax.png" alt="gPCKax" tabindex="0" loading="lazy"><figcaption>gPCKax</figcaption></figure>
<h4> vuex——终极的组件之间数据共享方案</h4>
<p>vuex 可以让组件之间的数据共享变得高效、清晰、且易于维护。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/0HtmYq.png" alt="0HtmYq" tabindex="0" loading="lazy"><figcaption>0HtmYq</figcaption></figure>
<p>创建一个共享的 store，存取数据都通过 store，实现不同组件之间的数据共享。</p>
<h3> vue3.x 中全局配置 axios</h3>
<h4> 为什么要全局配置 axios？</h4>
<ol>
<li>每个组件中都需要导入 axios 包（代码臃肿）</li>
<li>没吃发请求都需要填写完整的请求路径（不利于后期的维护）</li>
</ol>
<h4> 如何全局配置 axios？</h4>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/CwAmsY.png" alt="CwAmsY" tabindex="0" loading="lazy"><figcaption>CwAmsY</figcaption></figure>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> ref 的使用</h3>
<p>ref 是用于辅助开发者获得 DOM 元素或者组件的引用的。（不建议使用 jQuery 获取 DOM 元素，建议使用 ref）</p>
<h4> 使用 ref 获取 DOM 元素</h4>
<p>vue 在每个组件的引用中(this)都添加了一个<code>$refs</code>的属性，这个属性默认指向一个空对象，若开发者需要获取某个 DOM 元素，可以为该 DOM 元素添加属性 <code>ref=”name1”</code>，则可以使用 <code>this.$refs.name1</code> 获取该 DOM 元素的引用。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 使用 ref 引用组件实例</h4>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 要引用的对象还没有渲染怎么办？使用 $.nextTick(callback) 方法</h4>
<p>组件的 <code>$nextTick(cb)</code> 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 动态组件</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>动态组件指的是动态切换组件的显示和隐藏。vue 提供了一个内置的<code>&lt;component&gt;</code> 组件，专门用来实现组件的动态渲染。</p>
</div>
<ol>
<li><code>&lt;component&gt;</code> 是组件的占位符</li>
<li>通过 is 属性动态指定要渲染的组件名称</li>
<li><code>&lt;component is=”要渲染的组件的名称”&gt;&lt;/component&gt;</code></li>
</ol>
<h4> 使用 keep-alive 保持组件状态</h4>
<p>使用<code>&lt;component&gt;</code>时，若切换成其他组件，则原本的组件将会被销毁，其状态无法保持，可以使用<code>&lt;keep-alive&gt;</code>标签将<code>&lt;component&gt;</code>进行包裹，以保持切换走的组件的状态。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 插槽</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>插槽（Slot）是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把<strong>不确定的、希望用户指定的部分</strong>定义为插槽。</p>
</div>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/vZewR9.png" alt="vZewR9" tabindex="0" loading="lazy"><figcaption>vZewR9</figcaption></figure>
<p>可以把插槽认为是组件封装期间，为用户预留的<strong>内容的占位符</strong>。</p>
<h4> 插槽的基础用法</h4>
<p>在封装组件时，可以通过<code>&lt;slot&gt;</code>元素定义插槽，在使用时组件标签包裹的内容将会插入到插槽中。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>若没有定义插槽，则组件包裹的任何内容都会被丢弃。</p>
</div>
<h4> 插槽的后备内容</h4>
<p>通过<code>&lt;slot&gt;</code>元素定义插槽时，可以在其中定义后备内容，若用户未提供自定义内容，则显示后备内容。</p>
<h4> 具名插槽</h4>
<p>如果在封装组件时需要预留多个插槽节点，则需要为每个<code>&lt;slot&gt;</code>插槽指定具体的 name 名称。这种带有具体名称的插槽叫做“具名插槽”。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/nWdPi4.png" alt="nWdPi4" tabindex="0" loading="lazy"><figcaption>nWdPi4</figcaption></figure>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>没有 name 名称的插槽会有隐含的名称叫做“default”</p>
</div>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/eGacvB.png" alt="eGacvB" tabindex="0" loading="lazy"><figcaption>eGacvB</figcaption></figure>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p><code>v-slot:</code>可以简写为<code>#</code>，即<code>v-slot:header</code> → <code>#header</code></p>
</div>
<h4> 作用域插槽</h4>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/I0YDN5.png" alt="I0YDN5" tabindex="0" loading="lazy"><figcaption>I0YDN5</figcaption></figure>
<p>省略了插槽的 props 属性的介绍，有缘再见吧。</p>
<h3> 自定义指令</h3>
<p>vue 官方提供了 v-for, v-model 等常用的内置指令。除此之外，vue 还允许开发者自定义指令。</p>
<p>我想省略了 orz。</p>
<h2> vue 路由</h2>
<h3> 前端路由的概念与原理</h3>
<p>路由就是<strong>对应关系</strong>。路由分为两大类：</p>
<ol>
<li>后端路由：后端路由指的是<strong>请求方法、请求地址</strong>与<strong>function 处理函数</strong>之间的<strong>对应关系</strong>。</li>
<li>前端路由：前端路由指的是<strong>Hash 地址</strong>与<strong>组件</strong>之间的<strong>对应关系</strong>。</li>
</ol>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>在 SPA 中，web 网站只有唯一的一个 HTML 页面，<strong>所有组件的展示与切换</strong>都在这为一的一个页面内完成。此时，<strong>不同组件之间的切换</strong>需要通过<strong>前端路由</strong>来实现。</p>
</div>
<h4> 前端路由的工作方式</h4>
<ol>
<li>用户点击了页面上的路由地址</li>
<li>导致了 URL 地址栏中的 Hash 值发生了变化</li>
<li>前端路由监听到了 Hash 地址的变化</li>
<li>前端路由把当前 Hash 地址对应的组件渲染到浏览器中</li>
</ol>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/HbwSnR.png" alt="HbwSnR" tabindex="0" loading="lazy"><figcaption>HbwSnR</figcaption></figure>
<h4> 实现简易的前端路由</h4>
<ol>
<li>导入并注册 MyHome、MyMovie、MyAbout 三个组件：</li>
</ol>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>通过<code>&lt;component&gt;</code>标签的 is 属性，动态切换要显示的组件：</li>
</ol>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>在组件的结构中声明如下 3 个<code>&lt;a&gt;</code>连接，通过点击不同的<code>&lt;a&gt;</code>连接，切换浏览器地址栏中的 Hash 值：</li>
</ol>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>在 created 生命周期函数中监听浏览器地址栏中 Hash 地址的变化，动态切换要展示的组件的名称：</li>
</ol>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> vue-router 的基本使用</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>vue-router 是 vue 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换。</p>
</div>
<ul>
<li>vue-router 3.x：对应 vue2.x ：<a href="https://router.vuejs.org/zh" target="_blank" rel="noopener noreferrer">https://router.vuejs.org/zh</a></li>
<li>vue-router 4.x：对应 vue 3.x ：<a href="https://next.router.vuejs.org" target="_blank" rel="noopener noreferrer">https://next.router.vuejs.org</a></li>
</ul>
<h4> vue-router4.x 的基本使用步骤</h4>
<ul>
<li>
<p><strong>在项目中安装 vue-router</strong></p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>定义路由组件</strong><br>
就是定义自己的组件，如 MyHome.vue, MyMovie.vue, MyAbout.vue</p>
</li>
<li>
<p><strong>声明路由链接与占位符</strong><br>
可以使用<code>&lt;router-link&gt;</code>标签来声明路由链接，并使用<code>&lt;router-view&gt;</code>标签来声明路由占位符。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>创建路由模块</strong><br>
在项目中创建 router.js 路由模块，在其中按照如下 4 个步骤创建并得到路由的实例对象：</p>
<ol>
<li>从 vue-router 中按需导入两个方法</li>
<li>导入需要使用路由控制的组件</li>
<li>创建路由实例对象</li>
<li>向外共享路由实例对象</li>
<li>在 main.js 中导入并挂载路由模块</li>
</ol>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>导出并挂载路由模块</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> vue-router 的高级用法</h3>
<h4> 路由重定向</h4>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C，从而展示特定的组件页面。</p>
</div>
<p>通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 为激活的路由链接设置高亮样式</h4>
<ol>
<li>
<p><strong>默认的高亮 class 类</strong>：被激活的路由链接，默认会应用一个叫做 router-link-active 的类名。开发者可以使用此类名选择器，为激活的路由链接设置高亮样式：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>自定义路由高亮的 class 类</strong>：开发者可以基于 linkActiveClass 属性，自定义路由链接被激活时所应用的类名：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h4> 嵌套路由</h4>
<p>通过路由实现组件的嵌套展示，叫做嵌套路由。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/um5ec9.png" alt="um5ec9" tabindex="0" loading="lazy"><figcaption>um5ec9</figcaption></figure>
<ol>
<li>
<p>声明子路由链接和子路由占位符（声明在子组件内部即可）</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>在父路由规则中，通过 children 属性嵌套声明子路由规则</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h4> 动态路由匹配</h4>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>动态路由指的是：把 Hash 地址中的<strong>可变部分</strong>定义为<strong>参数项</strong>，从而提高路由规则的可复用性。</p>
</div>
<p>在 vue-router 中使用英文的冒号（:）来定义路由的参数：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>$route.params</code> 对象获取动态匹配的参数值。</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>props</code> 接收路由参数，需要在路由规则中开启：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 编程式导航</h4>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>编程式导航 vs 声明式导航：通过调用 API（调用 location.href）实现导航的方式叫做编程式导航，而通过点击链接（a 标签）实现导航的方式称为声明式导航。</p>
</div>
<p><strong>vue-router 中的编程式导航 API</strong></p>
<ul>
<li>this.$router.push(’hash 地址’)：跳转到指定的 hash 地址</li>
<li>this.$router.go(数值 n)：实现导航历史的前进、后退（-1）</li>
</ul>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 命名路由</h4>
<p>通过 name 属性为路由规则定义名称的方式，叫做命名路由：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：命名路由的 name 值不能重复。</p>
<p>使用命名路由可以在<code>&lt;router-link&gt;</code>中直接使用其名称，而不用显示地写 hash 地址：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 导航守卫</h4>
<p>导航守卫可以控制路由的访问权限。</p>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/iSrYhO.png" alt="iSrYhO" tabindex="0" loading="lazy"><figcaption>iSrYhO</figcaption></figure>
<h3> 如何声明全局导航守卫</h3>
<p><strong>全局导航守卫</strong>会<strong>拦截每个路由规则</strong>，从而对每个路由进行<strong>访问权限</strong>的控制。可以按照如下的方式定义全局导航守卫：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 守卫方法的 3 个参数</h4>
<p>全局导航守卫的守卫方法中接收 3 个形参，格式为：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>如果不接收第 3 个形参，则默认允许用户访问每一个路由。如果接收了 next 形参，则必须调用 next()函数，否则不允许用户访问该路由。</p>
</div>
<p>next 函数的 3 种调用方式：</p>
<ul>
<li>直接放行：next()</li>
<li>强制其停留在当前页面：next(false)</li>
<li>强制其跳转到登录页面：next(’/login’)</li>
</ul>
<h4> 结合 token 控制后台主页的访问权限</h4>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> vue 项目的创建</h2>
<h3> 如何快速创建 vue 的 SPA 项目</h3>
<ol>
<li>基于 vite 创建 SPA 项目
<ul>
<li>仅支持 3.x</li>
<li>不基于 webpack</li>
<li>速度快</li>
<li>小而巧</li>
</ul>
</li>
<li>给予 vue-cli 创建 SPA 项目
<ul>
<li>支持 2.x 与 3.x</li>
<li>基于 webpack</li>
<li>较慢</li>
<li>大而全</li>
</ul>
</li>
</ol>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> vite 的基本使用</h3>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/ZG3kP3.png" alt="ZG3kP3" tabindex="0" loading="lazy"><figcaption>ZG3kP3</figcaption></figure>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/yITax7.png" alt="yITax7" tabindex="0" loading="lazy"><figcaption>yITax7</figcaption></figure>
<h4> vite 项目的运行流程</h4>
<p>在工程化的项目中，vue 要做的事情很单纯：通过 <code>main.js</code> 把 <code>App.vue</code> 渲染到 <code>index.html</code> 的指定区域中。</p>
<p>其中：</p>
<ol>
<li><code>App.vue</code> 用来编写待渲染的模板结构</li>
<li><code>index.html</code> 中需要预留一个 <code>el</code> 区域</li>
<li><code>main.js</code> 把 <code>App.vue</code> 渲染到了 <code>index.html</code> 所预留的区域中</li>
</ol>
<h4> App.vue</h4>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> main.js</h4>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="/code/frontend/vue_todos.html" target="blank">Todos - Vite 项目案例</a></p>
<h3> vue-cli 的使用</h3>
<p><a href="http://cli.vuejs.org/zh" target="_blank" rel="noopener noreferrer">Vue CLI</a></p>
<h4> 基于 vue ui 创建 vue 项目</h4>
<ol>
<li>运行 <code>vue ui</code> 命令，自动在浏览器中打开创建项目的可视化面板。</li>
</ol>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/CALMwI.png" alt="CALMwI" tabindex="0" loading="lazy"><figcaption>CALMwI</figcaption></figure>
<ol start="2">
<li>填写项目名称</li>
<li>在预设页面选择手动配置项目</li>
</ol>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/xHZnib.png" alt="xHZnib" height="300" tabindex="0" loading="lazy"><figcaption>xHZnib</figcaption></figure>
<ol start="4">
<li>在功能页面勾选需要安装的功能</li>
</ol>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/rwl84Y.png" alt="rwl84Y" tabindex="0" loading="lazy"><figcaption>rwl84Y</figcaption></figure>
<ol start="5">
<li>在配置页面勾选 vue 的版本和需要的预处理器</li>
</ol>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/cl0cMR.png" alt="cl0cMR" tabindex="0" loading="lazy"><figcaption>cl0cMR</figcaption></figure>
<figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/WSUYun.png" alt="WSUYun" tabindex="0" loading="lazy"><figcaption>WSUYun</figcaption></figure>
<h4> 基于命令行创建 vue 项目</h4>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> vue 组件库</h2>
<h3> 什么是 vue 组件库</h3>
<p>在实际开发中，前端开发者可以把自己封装的.vue 组件整理、打包、并发布为 npm 的包，从而供其他人下载和使用。这种可以直接下载并在项目中使用的现成组件，就叫做 vue 组件库。</p>
<h3> vue 组件库与 bootstrap 的区别</h3>
<ul>
<li>bootstrap 只提供了纯粹的原材料（css 样式、HTML 结构以及 JS 特效），需要由开发者做进一步的组装和改造。</li>
<li>vue 组件库是遵循 vue 语法、高度定制的现成组件，开箱即用的。</li>
</ul>
<h3> 最常用的 vue 组件库</h3>
<ul>
<li>PC 端
<ul>
<li>Element UI</li>
<li>View UI</li>
</ul>
</li>
<li>移动端
<ul>
<li>Mint UI</li>
<li>Vant</li>
</ul>
</li>
</ul>
<h3> Element UI</h3>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>是由饿了么前端团队开源的一套 PC 端 vue 组件库。</p>
</div>
<ul>
<li>vue2 使用旧版的 Element UI</li>
<li>vue3 使用新版的 <a href="https://element-plus.gitee.io/zh-CN/guide/design.html" target="_blank" rel="noopener noreferrer">Element Plus</a></li>
</ul>
<h4> 安装</h4>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 引入 element-ui</h4>
<ul>
<li>完整引入：操作简单，但体积过大</li>
<li>按需引入：操作复杂，优化体积</li>
</ul>
<h5> 完整引入</h5>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 按需引入</h5>
<p>自动导入（推荐）</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>手动导入（不推荐就不写啦）</p>
<h2> axios+vue</h2>
<ul>
<li>axios 回调函数中的 <code>this</code> 已经改变，无法访问到 <code>data</code> 中数据</li>
<li>把 <code>this</code> 保存起来，回调函数中直接使用保存的 <code>this</code> 即可</li>
</ul>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 配置全局 axios</h3>
<p>vue2.x</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 解决跨域问题</h3>
<ul>
<li>使用一个代理服务器来解决跨域问题（这个代理服务器部署在 vue 相同的端口）</li>
<li>将 baseURL 改为 vue 项目的运行地址，因此不存在跨域</li>
<li>当 vue 发现请求的接口不存在，把请求转交给 proxy 代理</li>
<li>代理把请求的根路径替换为 devServer.proxy 属性的值，发起真正的请求</li>
<li>代理把请求到的数据，转发给 axios</li>
</ul>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://timpcfan-site.cdn.bcebos.com/imgs/1Ku8ff.png" alt="1Ku8ff" tabindex="0" loading="lazy"><figcaption>1Ku8ff</figcaption></figure>
<h2> 部署 vue 项目到 docker</h2>
<p><a href="https://cli.vuejs.org/guide/deployment.html#docker-nginx" target="_blank" rel="noopener noreferrer">Deployment | Vue CLI</a></p>
<h2> 设置 HTTPS</h2>
<p>vue.config.js</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 问题收集</h2>
<h3> props 属性是只读的不能使用 v-model 怎么办？</h3>
<p><a href="https://b23.tv/P8YRl6W" target="_blank" rel="noopener noreferrer">https://b23.tv/P8YRl6W</a></p>
<p>把它转存到 data 中，data 中的数据是可读可写的。</p>
<h2> 案例收集</h2>
<h3> 计数器</h3>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 图片切换</h3>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 记事本</h3>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="http://timpcfan-site.cdn.bcebos.com/imgs/AYFU9u.png" type="image/png"/>
    </item>
    <item>
      <title>前端工程化与Webpack</title>
      <link>https://newzone.top/code/frontend/webpack.html</link>
      <guid>https://newzone.top/code/frontend/webpack.html</guid>
      <source url="https://newzone.top/rss.xml">前端工程化与Webpack</source>
      <description>前端工程化 前端工程化的四个「现代化」 模块化（js 的模块化，css 的模块化，资源的模块化） 组件化（复用现有的 UI 结构，样式，行为） 规范化（目录结构的画风，编码规范化，接口规范化，文本规范化， Git 分支管理） 自动化（自动化构建，自动部署，自动化测试） 什么是前端开发工程化？ 在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。</description>
      <category>笔记</category>
      <category>前端</category>
      <pubDate>Mon, 14 Aug 2023 09:07:38 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前端工程化</h2>
<div class="hint-container tip">
<p class="hint-container-title">前端工程化的四个「现代化」</p>
<ul>
<li>模块化（js 的模块化，css 的模块化，资源的模块化）</li>
<li>组件化（复用现有的 UI 结构，样式，行为）</li>
<li>规范化（目录结构的画风，编码规范化，接口规范化，文本规范化， Git 分支管理）</li>
<li>自动化（自动化构建，自动部署，自动化测试）</li>
</ul>
</div>
<h3> 什么是前端开发工程化？</h3>
<p>在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。</p>
<p>企业中的 Vue 项目和 React 项目，都是基于工程化的方式开发的。</p>
<h3> 前端工程化的解决方案</h3>
<p>目前流行的：</p>
<ul>
<li><a href="http://www.webpackjs.com" target="_blank" rel="noopener noreferrer">webpack</a></li>
<li><a href="http://zh.parceljs.org" target="_blank" rel="noopener noreferrer">parcel</a></li>
</ul>
<h2> webpack</h2>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>webpack 是前端项目工程化的具体解决方案，它提供了友好的<strong>前端模块化开发</strong>支持，以及<strong>代码压缩混淆</strong>、<strong>处理浏览器端 JavaScript 的兼容性</strong>、<strong>性能优化</strong>等强大的功能。</p>
</div>
<h3> 创建一个 npm 的项目</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 在项目中安装 webpack</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中，<code>-D</code> 表示 <code>--save-dev</code>，将安装的包写入 <code>devDependencies</code> 中，表示开发时才会被利用到。默认为 <code>-S</code> 表示 <code>--save</code> ，将安装的包写入 <code>depedencies</code> 中，表示在开发以及生产环境中都会被用到。</p>
<h3> 在项目中配置 webpack</h3>
<ol>
<li>在项目根目录中，创建名为 <code>webpack.config.js</code> 的 webpack 配置文件，并初始化如下的基本配置：</li>
</ol>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>在 <code>package.json</code> 的 <code>scripts</code> 节点下，新增 dev 脚本如下：</li>
</ol>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>在终端中运行 <code>npm run dev</code> 命令，启动 webpack 进行项目的打包构建</li>
</ol>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>webpack 会将所有依赖的 js 文件都整合到一个 main.js 文件中，在 html 中应该直接引用整合后的 main.js 文件。</p>
</div>
<h3> webpack 中的默认约定</h3>
<p>在 webpack4.x 和 5.x 的版本中，有如下的默认约定：</p>
<ol>
<li>默认的打包入口文件为：src→index.js</li>
<li>默认的输出文件路径为：dist→main.js</li>
</ol>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>注：可在 <code>webpack.config.js</code> 中修改打包的默认约定</p>
<p>通过 entry 节点指定打包的入口，通过 output 节点指定打包的出口。</p>
</div>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> webpack 插件的使用</h2>
<h3> 一些常用的插件</h3>
<ol>
<li><strong>webpack-dev-server</strong>
<ul>
<li>每当修改了源代码，webpack 会自动进行项目的打包和构建</li>
</ul>
</li>
<li><strong>html-webpack-plugin</strong>
<ul>
<li>webpack 中的 HTML 插件（类似于一个模板引擎插件）</li>
<li>可以通过此插件自定义 index.html 页面的内容</li>
<li>插件生成的 html 页面中会自动注入了打包的 main.js 文件</li>
</ul>
</li>
</ol>
<h3> 如何使用<strong>webpack-dev-server</strong></h3>
<p>安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改 <code>package.json</code> 中的 <code>scripts</code> 的 <code>dev</code> 命令如下：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次运行 <code>npm run dev</code> 命令，重新进行项目的打包</p>
<p>在浏览器中访问：<a href="http://localhost:8080" target="_blank" rel="noopener noreferrer">http://localhost:8080</a> 地址，查看自动打包效果</p>
<div class="hint-container info">
<p class="hint-container-title">一些坑</p>
<ul>
<li>该插件自动打包生成的 js 文件是存储在内存中的，因此在物理磁盘路径下无法看见</li>
<li>该插件生成的 js 文件默认的位置是项目的根目录</li>
</ul>
</div>
<h3> 如何使用 html-webpack-plugin</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>为什么要用 html-webpack-plugin？</p>
<p>使用上面的插件时，访问 <a href="http://localhost:8080" target="_blank" rel="noopener noreferrer">http://localhost:8080</a> 地址，默认是打开根目录，但实际的项目入口在 src 文件夹中，因此希望将 src 文件夹中的 index.html 复制一份到根目录下，使得可以直接访问。</p>
</div>
<p>安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>配置</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">启动时自动打开浏览器</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h3> webpack 中的 loader</h3>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>webpack 默认只能处理.js 文件，当遇到其他文件时它会寻找有没有对应的 loader 能够进行处理。例如，在处理 css 文件时，需要安装处理 css 文件的 loader。</p>
</div>
<p>安装 loader：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>webpack.config.js</code> 的 <code>module-&gt;rules</code> 数组中，添加 loader 规则如下：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中， <code>test</code> 表示匹配的文件类型，<code>use</code> 表示对应要调用的 loader</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<ul>
<li>use 数组中指定的 loader 顺序是固定的</li>
<li>多个 loader 的调用顺序是：<strong>从后往前调用</strong></li>
</ul>
</div>
<h4> 配置 babel-loader</h4>
<p>不想看了，省略！</p>
<p>要创建一个 <code>babel.config.js</code> 文件</p>
<h3> 自动清理 dist 目录</h3>
<p>包：clean-webpack-plugin</p>
<p>使用方法：<a href="https://www.npmjs.com/package/clean-webpack-plugin" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/clean-webpack-plugin</a></p>
<h3> 解决 Source Map 的问题</h3>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>由于 webpack 会进行混淆代码，因此运行时报错的行号可能与源代码的行号不一致，可以使用下面的方法来保持一致：</p>
</div>
<p>在配置文件中添加：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>考虑到安全原因，建议使用折衷的 <code>nonsources-source-map</code></p>
</div>
<h3> @符号的定义</h3>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>import 时，若使用相对路径会使得代码非常繁琐，可以使用@符号代表 src 目录的绝对路径，从外往里指定路径。</p>
</div>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>游戏笔记</title>
      <link>https://newzone.top/life/game/</link>
      <guid>https://newzone.top/life/game/</guid>
      <source url="https://newzone.top/rss.xml">游戏笔记</source>
      <description>1- 目录 1.1- 玩游戏 1.1.1- 单机游戏（联机） 环世界Rimword （目前还没完成一周目的游戏） Overcooked | 分手厨房 1-2 It takes two | 双人成行 老头环 | eldenring</description>
      <category>笔记</category>
      <pubDate>Mon, 14 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1- 目录</h1>
<h2> 1.1- 玩游戏</h2>
<h3> 1.1.1- 单机游戏（联机）</h3>
<ul>
<li>环世界Rimword （目前还没完成一周目的游戏）</li>
<li>Overcooked | 分手厨房 1-2</li>
<li>It takes two | 双人成行</li>
<li>老头环 | eldenring</li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>